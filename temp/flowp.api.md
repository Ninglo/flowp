## API Report File for "flowp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class Barrier implements PromiseLike<void> {
    constructor();
    // (undocumented)
    then<TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): PromiseLike<TResult1 | TResult2>;
    // (undocumented)
    unlock(): void;
    // (undocumented)
    get unlocked(): boolean;
}

// @public
export class Channel<T> implements PipeSource<T>, PipeTarget<T> {
    // @internal (undocumented)
    [read](value: T): void;
    constructor(capacity?: number);
    get capacity(): number;
    // Warning: (ae-forgotten-export) The symbol "ChannelFullError" needs to be exported by the entry point index.d.ts
    static ChannelFullError: typeof ChannelFullError;
    close(): void;
    get closed(): boolean;
    // Warning: (ae-forgotten-export) The symbol "ClosedChannelError" needs to be exported by the entry point index.d.ts
    static ClosedChannelError: typeof ClosedChannelError;
    pause(): void;
    // Warning: (ae-incompatible-release-tags) The symbol "pipe" is marked as @public, but its signature references "ChannelPipeOptions" which is marked as @internal
    pipe(target: PipeTarget<T>, options?: ChannelPipeOptions): void;
    receive(): Promise<T>;
    resume(): void;
    send(value: T): Promise<void>;
    sendAsync(value: Promise<T>): Promise<void>;
    get size(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "stream" is marked as @public, but its signature references "ChannelStream" which is marked as @internal
    stream(): ChannelStream<T>;
    tryReceive(): T | undefined;
    trySend(value: T): void;
    unpipe(): void;
}

// @public
export class ChannelHub<T = unknown> implements PipeTarget<T> {
    // @internal (undocumented)
    [read](value: T): void;
    constructor(writers?: Channel<T>[], readers?: Channel<T>[]);
    broadcast(value: T): void;
    close(): void;
    disconnect(ch: Channel<T>): void;
    static from<T>(writers?: Channel<T>[], readers?: Channel<T>[]): ChannelHub<T>;
    reader(): Channel<T>;
    writer(): Channel<T>;
}

// Warning: (ae-internal-missing-underscore) The name "ChannelPipeOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ChannelPipeOptions {
    onPipeError?: (err: unknown) => any;
}

// Warning: (ae-internal-missing-underscore) The name "ChannelStream" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface ChannelStream<T> extends AsyncIterable<T> {
    // (undocumented)
    next: () => Promise<T>;
}

// @public (undocumented)
type ConsoleLevel = 'debug' | 'log' | 'warn' | 'error';

// Warning: (ae-incompatible-release-tags) The symbol "delegate" is marked as @alpha, but its signature references "Delegated" which is marked as @internal
//
// @alpha
export function delegate<T extends Promise<unknown>>(value: T): Delegated<T>;

// Warning: (ae-forgotten-export) The symbol "Callable" needs to be exported by the entry point index.d.ts
// Warning: (ae-internal-missing-underscore) The name "Delegated" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type Delegated<T> = (Awaited<T> extends Callable ? (...args: Parameters<Awaited<T>>) => ReturnType<Awaited<T>> : {
    readonly [K in keyof Awaited<T> & string as `$${K}`]: Delegated<Awaited<T>[K]>;
}) & Promise<Awaited<T>>;

// @public
export class Future<T = unknown> extends Promise<T> {
    // (undocumented)
    static get [Symbol.species](): PromiseConstructor;
    constructor();
    get fulfilled(): boolean;
    get pending(): boolean;
    // (undocumented)
    protected promiseState: symbol;
    get reject(): (error?: unknown) => void;
    // (undocumented)
    protected _reject: (error: unknown) => void;
    get rejected(): boolean;
    get resolve(): (value: T | PromiseLike<T>) => void;
    // (undocumented)
    protected _resolve: (value: T | PromiseLike<T>) => void;
    get settled(): unknown;
    // (undocumented)
    protected settledValue?: T | unknown;
}

// @public
const immediately: <T>(value?: T | undefined) => Promise<T | undefined>;

// @public
export class Mutex<V = void> {
    constructor();
    constructor(value: V);
    get canLock(): boolean;
    freeze(): void;
    get frozen(): boolean;
    // Warning: (ae-forgotten-export) The symbol "MutexGuard" needs to be exported by the entry point index.d.ts
    lock(timeout?: number): Promise<MutexGuard<V>>;
    schedule<T>(fn: (v: V) => T): Promise<Awaited<T>>;
    tryLock(): MutexGuard<V>;
    unfreeze(): Promise<void>;
    // (undocumented)
    protected _value: V;
}

// @public (undocumented)
interface Pipe<TIn, TOut> extends PipeTarget<TIn>, PipeSource<TOut> {
}

declare namespace pipe {
    export {
        read,
        PipeSource,
        PipeTarget,
        Pipe,
        Transform,
        ConsoleLevel,
        to
    }
}
export { pipe }

// @public
interface PipeSource<T> {
    // (undocumented)
    pipe: (target: PipeTarget<T>) => void;
    // (undocumented)
    unpipe: () => void;
}

// @public
interface PipeTarget<T, S = PipeSource<T>> {
    // Warning: (ae-incompatible-release-tags) The symbol "[read]" is marked as @public, but its signature references "read" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "[read]" is marked as @public, but its signature references "read" which is marked as @internal
    //
    // (undocumented)
    [read]: (value: T, source?: S) => void;
}

// @beta
export class Progress<Result = unknown, CurrentProgress = unknown> extends Future<Result> {
    constructor(initialProgress: CurrentProgress);
    // Warning: (ae-incompatible-release-tags) The symbol "inspect" is marked as @beta, but its signature references "ProgressInspectionResult" which is marked as @internal
    inspect(): ProgressInspectionResult<Result, CurrentProgress>;
    onProgress(listener: (progress: Readonly<CurrentProgress>) => unknown): () => boolean;
    get progress(): CurrentProgress;
    report(progress: CurrentProgress): void;
    static run<Result = unknown, CurrentProgress = unknown>(fn: (progress: Progress<Result, CurrentProgress>) => unknown, initialProgress: CurrentProgress): Progress<Result, CurrentProgress>;
}

// Warning: (ae-internal-missing-underscore) The name "ProgressInspectionResult" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ProgressInspectionResult<Result, Progress> = {
    state: 'pending';
    progress: Progress;
} | {
    state: 'fulfilled';
    value: Result;
} | {
    state: 'rejected';
    reason: unknown;
};

// @internal (undocumented)
const read: unique symbol;

// @public
export class Semaphore {
    constructor(permits?: number);
    acquire(timeout?: number): Promise<() => void>;
    freeze(): void;
    frozen?: Future<void>;
    grant(permits?: number): void;
    get isEmpty(): boolean;
    get isFull(): boolean;
    get permits(): number;
    get remain(): number;
    revoke(permits?: number): Promise<void>;
    schedule<T>(fn: () => T): Promise<Awaited<T>>;
    tryAcquire(): () => void;
    unfreeze(): Promise<void>;
}

// @public
const sleep: SleepTimer;

// @public
interface SleepTimer {
    // (undocumented)
    (ms: number): Promise<void>;
    // (undocumented)
    <T>(ms: number, value: T): Promise<T>;
}

// @public
const timeout: (ms: number, err?: string | Error) => Promise<unknown>;

declare namespace timers {
    export {
        SleepTimer,
        sleep,
        timeout,
        immediately
    }
}
export { timers }

// @public (undocumented)
const to: {
    <T>(fn: (v: T, s?: PipeSource<T> | undefined) => any): PipeTarget<T, PipeSource<T>>;
    console(level?: ConsoleLevel): {
        [read]: ((message?: any, ...optionalParams: any[]) => void) | ((message?: any, ...optionalParams: any[]) => void) | ((message?: any, ...optionalParams: any[]) => void) | ((message?: any, ...optionalParams: any[]) => void);
    };
};

// @public (undocumented)
class Transform<TIn, TOut> implements PipeTarget<TIn, PipeSource<TIn>>, PipeSource<TOut> {
    // @internal (undocumented)
    [read](value: TIn, source?: PipeSource<TIn>): void;
    constructor(handler: (value: TIn) => TOut);
    // (undocumented)
    handler: (value: TIn, source?: PipeSource<TIn>) => TOut;
    // (undocumented)
    pipe(target: PipeTarget<TOut>): void;
    // (undocumented)
    unpipe(): void;
}

// Warnings were encountered during analysis:
//
// src/protocol/pipeable.ts:74:10 - (ae-incompatible-release-tags) The symbol "[read]" is marked as @public, but its signature references "read" which is marked as @internal
// src/protocol/pipeable.ts:74:10 - (ae-incompatible-release-tags) The symbol "[read]" is marked as @public, but its signature references "read" which is marked as @internal

// (No @packageDocumentation comment for this package)

```
